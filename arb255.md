# Bijective Arithmetic Coding

## Overview

This document explains the bijective arithmetic coding implementation in `arb255.cpp`, which solves the fundamental problem of creating a true one-to-one (bijective) mapping between byte streams and bit streams without requiring explicit end-of-file markers.

## The Bijective Arithmetic Coding Problem

Traditional arithmetic coding faces several challenges:

1. **EOF Ambiguity**: Standard arithmetic coding requires an explicit EOF symbol or length prefix to know when to stop decoding
2. **Non-uniqueness**: Multiple encoded representations can decode to the same input
3. **Asymmetry**: The encoding is not bijective - you cannot uniquely reverse the process

The bijective arithmetic coding solution solves these problems by:
- Eliminating the need for EOF markers
- Ensuring each input has exactly one valid encoding
- Creating a true mathematical bijection between inputs and outputs

---

## Part 1: Bijective Mapping Between Byte Streams and Bit Streams

### The Finitely-Odd Bit Stream Concept

The key innovation is the **finitely-odd bit stream** format, which enables a bijective mapping between finite byte sequences and infinite bit sequences.

#### Definition

A finitely-odd bit stream is an infinite-length bit sequence with these properties:
1. There exists a final '1' bit at some finite position
2. All bits after the final '1' are '0' (infinite trailing zeros)
3. The stream can be conceptually written as: `...bits...1000000...` (infinite zeros)

#### Why This Works

```
Finite byte sequence:  [b0, b1, b2, ..., bN]
         ↕ bijection
Finitely-odd sequence: bits...10000000... (infinite)
```

The bijection works because:
- Every finite byte sequence maps to exactly one finitely-odd bit stream
- Every finitely-odd bit stream maps back to exactly one finite byte sequence
- The position of the final '1' bit uniquely determines where the "real" data ends

### Physical Encoding in Files

The implementation uses a clever encoding scheme to store finitely-odd streams in finite files:

#### End-of-Stream Detection Pattern

The code detects the end by looking for a specific byte pattern:
```
0x00 0x80
```

In the bit stream reading function (`r()`):
```cpp
// Detect finitely-odd end marker
if (bo == 0)
  zerf = 1;              // Detected 0x00 byte
else if (bo != M) {
  zerf = 0;
  onef = 0;
} else if (zerf == 1)
  onef = 1;              // Detected 0x80 after 0x00

// When both flags set and EOF reached, this is the end marker
if ((bn == EOF) && (onef + zerf) > 0) {
  onef = 0;
  zerf = 0;
  bn = M;                // Treat as 0x80 (10000000 in binary)
}
```

#### How It Works

1. **During Writing**: When the encoder finishes, it may output bytes. The last actual bit written is always a '1'
2. **Pattern Recognition**: The sequence 0x00 0x80 at EOF indicates we're at the final '1' bit
3. **Infinite Zeros**: After reading this final '1', the reader returns infinite '0' bits

#### Example

```
Actual bit stream: 1 0 1 1 0 0 0 0  0 0 0 0 0 0 0 0  1 0 0 0 0 0 0 0  [EOF]
Byte representation:        0xB0              0x00              0x80
                              ↑                ↑                  ↑
                        normal data       zero byte      final 1 bit (position 0)
```

After reading the final '1' bit (the leftmost bit of 0x80), all subsequent reads return '0', creating the infinite tail.

### Why Appending 0x00 Fails

**Question**: Why doesn't appending a zero byte to a complete encoded file let it decode to the same file?

**Answer**: The finitely-odd format has a unique termination property:

```
Original file:     ...data... [EOF detected at pattern 0x00 0x80]
                             ↑
                      final '1' bit here, then infinite zeros

Modified file:     ...data... 0x00 [appended]
                             ↑
                      EOF detection pattern BROKEN!
```

When you append 0x00:
1. The original EOF pattern `0x00 0x80 [EOF]` is disrupted
2. The new file becomes `...data... 0x00 0x00 [EOF]`
3. The decoder now looks for the pattern in the *new* position
4. The bit stream changes because the final '1' position has moved
5. **Result**: Different bit stream → different decoded output

The bijection is broken because **the byte sequence uniquely determines the bit sequence** through the EOF detection mechanism. Changing the byte sequence (by appending) changes which bit is considered "final", thus changing the entire bit stream interpretation.

---

## Part 2: Arithmetic Code Termination and Bijectivity

### The Standard Arithmetic Coding Problem

Traditional arithmetic coding maps an input sequence to a number in the interval [0, 1):
- Each symbol narrows the interval based on its probability
- The final interval represents the encoded message
- Any number in the final interval can represent the encoding

**Problem**: Multiple numbers in the final interval decode to the same message → **not bijective**

### Free End Management Solution

The bijective solution uses **free end management** to ensure unique termination.

#### What is a Free End?

A "free end" is a special value within the current arithmetic coding interval [low, high] that:
1. Is reserved as a potential termination marker
2. Has specific properties (follows an "odd number" sequence in binary representation)
3. Gets incremented systematically as encoding progresses

#### The Free End Sequence

Free ends follow a specific odd number sequence:
```
Binary representation of free ends (conceptually):
  Half = 100000...0  (0x8000000000000000)
  Then: 110000...0, 101000...0, 111000...0, ...

Pattern: Numbers of the form (2k+1) * 2^n where the sequence ensures
         systematic coverage of the interval
```

The `inc_fre()` function increments to the next valid free end:
```cpp
void inc_fre(void) {
  // Convert current free end to counter, increment, convert back
  fre_2_cnt();
  fcount++;
  freeetemp = cnt_2_fre();

  // Ensure new free end falls within [low, high]
  if (low <= freeend && freeend <= high) {
    return;  // Free end is valid
  }

  // Otherwise, search for valid free end within interval
  // ... (complex logic to find next valid odd number)
}
```

#### How Free Ends Maintain Bijectivity

During encoding (`encode_symbol()`):

```cpp
// After narrowing interval for symbol
if (FRX != 0) {
  // Free end outside interval - adjust it
  if (low > freeend)
    freeend = low;
  else if (freeend < high)
    freeend += 1;
} else if (freeend == Top_value) {
  freeend = low;
  FRX = 1;
} else if (CMOD == 0 || (freeend | Half) != Half) {
  inc_fre();  // Increment to next free end
}
```

**Key insight**: After encoding each symbol, we increment or adjust the free end. This means:
1. Each symbol encoding consumes one free end value
2. The sequence of free ends used is deterministic and unique
3. At termination, we output the current free end value
4. **The decoder can detect this exact free end value and know to stop**

### Termination Process

#### Encoding Termination

At the end of input (`encode_file()`):
```cpp
// Finalize encoding by writing the free end marker
fcount = Half;
for (; freeend != 0; fcount >>= 1) {
  ch = (fcount & freeend) != 0 ? 1 : 0;
  bit_plus_follow(ch);
  if (ch == 1) {
    freeend -= fcount;
  }
}
bit_plus_follow(0);  // Final bit (the '1' in finitely-odd format)
dasw(-2);            // Close bit stream
```

This writes out the free end value as a binary number, ending with the final '1' bit.

#### Decoding Termination

During decoding (`decode_symbol()`):
```cpp
// Check for end-of-stream: VALUE matches free end
if (ZEND == 1 && VALUE == freeend && FRX == 0)
  return -1;  // EOF detected
```

The decoder:
1. Maintains the same free end sequence as the encoder
2. Reads the bit stream and updates VALUE
3. When VALUE equals the current free end AND end-of-input detected → decoding complete
4. **This is unique**: Only one specific bit pattern (the free end) causes termination

### Why This Achieves Bijectivity with Unpacked Data

**Unpacked data** = The original bit stream before arithmetic coding

The process is bijective because:

1. **Forward Direction (Encode)**:
   ```
   Input bits → Arithmetic intervals → Free end sequence → Output bytes
        ↓              ↓                    ↓                    ↓
   Deterministic  One per bit      One per symbol         Unique EOF pattern
   ```

2. **Reverse Direction (Decode)**:
   ```
   Input bytes → Bit stream → Arithmetic intervals → Free end detection → Output bits
        ↓            ↓              ↓                      ↓                  ↓
   Unique EOF   Finitely-odd   Interval narrowing   Matches encode     Original bits
   ```

3. **Uniqueness Guarantee**:
   - Each input bit sequence produces a unique free end sequence
   - Each free end sequence produces a unique output byte sequence
   - Each output byte sequence decodes to the unique free end sequence
   - Each free end sequence reconstructs the unique input bit sequence

**Mathematical Property**:
```
f: BitStreams → ByteStreams  (encoding)
g: ByteStreams → BitStreams  (decoding)

g(f(x)) = x  for all x ∈ BitStreams  (perfect reconstruction)
f(g(y)) = y  for all y ∈ ValidByteStreams  (unique encoding)

Therefore: f and g are inverse functions → bijection!
```

---

## Part 3: EOF Treatment and File Integrity

### How EOF is Treated

The implementation has three levels of EOF handling:

#### 1. Physical File EOF
```cpp
bn = fgetc(f);
if (bn == EOF) {
  // Physical end of file reached
}
```

#### 2. Logical Stream EOF (Finitely-Odd Detection)
```cpp
// In r() function:
if ((bn == EOF) && (onef + zerf) > 0) {
  // Pattern 0x00 0x80 detected at physical EOF
  // This is the logical stream end marker
  bn = M;  // Treat last byte as 0x80
}
```

#### 3. Bit-Level EOF (Final '1' Bit)
```cpp
bo ^= l;  // Clear the bit
if ((bn != EOF) || (bo != 0))
  return 1;

// This was the last '1' bit
xx();  // Reset state
return -1;  // Signal end-of-stream
```

### Why Appending 0x00 Breaks Decoding

Let's trace through a concrete example:

#### Original File Structure
```
Bytes:     [data bytes...] 0x00 0x80 [EOF]
                              ↑    ↑
                           zero  final byte
                           byte  (10000000)

Bit reading:
- Read data bits normally
- See 0x00: set zerf = 1
- See 0x80: set onef = 1
- See EOF: recognize end pattern
- Bit 7 of 0x80 (the '1') is the FINAL bit
- Return -1, then infinite zeros
```

#### Modified File (0x00 Appended)
```
Bytes:     [data bytes...] 0x00 0x80 0x00 [EOF]
                              ↑    ↑    ↑
                           zero  NOT  NEW
                           byte  EOF  zero

Bit reading:
- Read data bits normally
- See 0x00: set zerf = 1
- See 0x80: set onef = 1
- See 0x00: zerf = 0, onef = 0 (pattern broken!)
  (because next byte is not EOF, it's another 0x00)
- See 0x00 again: set zerf = 1
- See EOF: detect new pattern here
- Now the FINAL '1' bit is somewhere in the appended byte's bit stream!
```

#### The Mathematical Reason

The byte-to-bit mapping is defined by:
```
Position of final '1' = f(byte_sequence)

where f includes the EOF detection logic.
```

When you append 0x00:
- `original_sequence = [b1, b2, ..., bN, 0x00, 0x80]`
- `modified_sequence = [b1, b2, ..., bN, 0x00, 0x80, 0x00]`

The function f gives:
- `f(original_sequence) = "final '1' at bit position P"`
- `f(modified_sequence) = "final '1' at bit position P + 8"` (shifted by one byte!)

Since the final '1' position changed, the **entire finitely-odd bit stream is different**:
```
Original:  [bits...] 1 0 0 0 0 0 0 0 ...
                     ↑
              position P (in 0x80)

Modified:  [bits...] 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ...
                     ↑                 ↑
              (was here)        position P+8 (in appended 0x00)
```

### Decoder Behavior

The arithmetic decoder (`decode_symbol()`) relies on the bit stream being exactly correct:

```cpp
if (ZEND == 1 && VALUE == freeend && FRX == 0)
  return -1;  // Stop when free end matched
```

If the bit stream changes (because of the appended byte):
1. The VALUE at each step will be different
2. The free end matching won't occur at the right position
3. The decoder will either:
   - Stop too early (if it happens to match a free end earlier)
   - Stop too late (if the match occurs later)
   - Error out (if consistency checks fail)

**Result**: The decoded output will be different from the original input, breaking the bijection.

---

## Summary

The bijective arithmetic coding in `arb255.cpp` achieves true bijectivity through three key mechanisms:

1. **Finitely-Odd Bit Streams**: Maps finite byte sequences to infinite bit sequences with a unique final '1' bit, detected via the 0x00 0x80 EOF pattern

2. **Free End Management**: Ensures unique arithmetic code termination by systematically reserving and using specific interval values, making each encoding deterministic and reversible

3. **Integrated EOF Handling**: The EOF is not a separate marker but inherent in the bit stream structure itself, making any modification (like appending bytes) change the entire bit stream interpretation

This creates a true mathematical bijection where:
- Every input bit sequence has exactly one encoded byte sequence
- Every valid encoded byte sequence decodes to exactly one bit sequence
- The mapping is fully reversible without any ambiguity or need for external markers
